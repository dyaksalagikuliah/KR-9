// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title VulnerabilityValidator
 * @notice Handles validation and severity assessment of vulnerability submissions
 * @dev Uses multi-sig approach with professional validators
 */
contract VulnerabilityValidator is AccessControl, ReentrancyGuard {

    bytes32 public constant VALIDATOR_ROLE = keccak256("VALIDATOR_ROLE");
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    enum VulnerabilitySeverity { None, Low, Medium, High }
    enum ValidationStatus { Pending, Approved, Rejected }

    struct ValidationVote {
        address validator;
        VulnerabilitySeverity suggestedSeverity;
        bool isValid;
        string comments;
        uint256 votedAt;
    }

    struct ValidationRequest {
        uint256 submissionId;
        uint256 bountyId;
        address hunter;
        VulnerabilitySeverity finalSeverity;
        ValidationStatus status;
        uint256 totalVotes;
        uint256 requiredVotes;
        uint256 approvalCount;
        uint256 rejectionCount;
        bool isFinalized;
    }

    // State variables
    address public bountyManager;
    uint256 public requiredValidations = 3; // Minimum 3 validators

    mapping(uint256 => ValidationRequest) public validationRequests;
    mapping(uint256 => mapping(address => ValidationVote)) public votes;
    mapping(uint256 => address[]) public validationVoters;
    mapping(address => uint256) public validatorReputationScore;
    mapping(address => uint256) public validatorTotalValidations;

    // Events
    event ValidationRequested(uint256 indexed submissionId, uint256 indexed bountyId);
    event VoteCast(uint256 indexed submissionId, address indexed validator, VulnerabilitySeverity severity, bool isValid);
    event ValidationFinalized(uint256 indexed submissionId, VulnerabilitySeverity finalSeverity, bool isValid);
    event ValidatorAdded(address indexed validator);
    event ValidatorRemoved(address indexed validator);

    modifier onlyBountyManager() {
        require(msg.sender == bountyManager, "Only bounty manager");
        _;
    }

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /**
     * @notice Request validation for a submission (called by BountyManager)
     * @param _submissionId The submission ID
     * @param _bountyId The bounty ID
     * @param _hunter The hunter address
     */
    function requestValidation(
        uint256 _submissionId,
        uint256 _bountyId,
        address _hunter
    ) external onlyBountyManager {
        require(
            validationRequests[_submissionId].submissionId == 0,
            "Already requested"
        );

        validationRequests[_submissionId] = ValidationRequest({
            submissionId: _submissionId,
            bountyId: _bountyId,
            hunter: _hunter,
            finalSeverity: VulnerabilitySeverity.None,
            status: ValidationStatus.Pending,
            totalVotes: 0,
            requiredVotes: requiredValidations,
            approvalCount: 0,
            rejectionCount: 0,
            isFinalized: false
        });

        emit ValidationRequested(_submissionId, _bountyId);
    }

    /**
     * @notice Cast a validation vote
     * @param _submissionId The submission ID
     * @param _severity Suggested severity level
     * @param _isValid Whether the submission is valid
     * @param _comments Validator comments
     */
    function castVote(
        uint256 _submissionId,
        VulnerabilitySeverity _severity,
        bool _isValid,
        string memory _comments
    ) external onlyRole(VALIDATOR_ROLE) nonReentrant {
        ValidationRequest storage request = validationRequests[_submissionId];
        require(!request.isFinalized, "Already finalized");
        require(
            votes[_submissionId][msg.sender].validator == address(0),
            "Already voted"
        );

        votes[_submissionId][msg.sender] = ValidationVote({
            validator: msg.sender,
            suggestedSeverity: _severity,
            isValid: _isValid,
            comments: _comments,
            votedAt: block.timestamp
        });

        validationVoters[_submissionId].push(msg.sender);
        request.totalVotes++;

        if (_isValid) {
            request.approvalCount++;
        } else {
            request.rejectionCount++;
        }

        emit VoteCast(_submissionId, msg.sender, _severity, _isValid);

        // Auto-finalize if enough votes
        if (request.totalVotes >= request.requiredVotes) {
            _finalizeValidation(_submissionId);
        }
    }

    /**
     * @notice Finalize validation after enough votes
     * @param _submissionId The submission ID
     */
    function _finalizeValidation(uint256 _submissionId) internal {
        ValidationRequest storage request = validationRequests[_submissionId];
        require(!request.isFinalized, "Already finalized");

        bool isValid = request.approvalCount > request.rejectionCount;

        if (isValid) {
            request.finalSeverity = _calculateFinalSeverity(_submissionId);
            request.status = ValidationStatus.Approved;
        } else {
            request.finalSeverity = VulnerabilitySeverity.None;
            request.status = ValidationStatus.Rejected;
        }

        request.isFinalized = true;

        // Update validator reputations
        _updateValidatorReputations(_submissionId, isValid);

        // Callback to BountyManager
        IBountyManager(bountyManager).validateSubmission(
            _submissionId,
            uint8(request.finalSeverity),
            isValid
        );

        emit ValidationFinalized(_submissionId, request.finalSeverity, isValid);
    }

    /**
     * @notice Calculate final severity based on validator votes
     * @param _submissionId The submission ID
     */
    function _calculateFinalSeverity(uint256 _submissionId)
        internal
        view
        returns (VulnerabilitySeverity)
    {
        address[] memory voters = validationVoters[_submissionId];

        uint256 lowCount = 0;
        uint256 mediumCount = 0;
        uint256 highCount = 0;

        for (uint256 i = 0; i < voters.length; i++) {
            ValidationVote memory vote = votes[_submissionId][voters[i]];

            if (!vote.isValid) continue;

            if (vote.suggestedSeverity == VulnerabilitySeverity.Low) {
                lowCount++;
            } else if (vote.suggestedSeverity == VulnerabilitySeverity.Medium) {
                mediumCount++;
            } else if (vote.suggestedSeverity == VulnerabilitySeverity.High) {
                highCount++;
            }
        }

        // Return highest severity with majority vote
        if (highCount >= mediumCount && highCount >= lowCount && highCount > 0) {
            return VulnerabilitySeverity.High;
        } else if (mediumCount >= lowCount && mediumCount > 0) {
            return VulnerabilitySeverity.Medium;
        } else if (lowCount > 0) {
            return VulnerabilitySeverity.Low;
        }

        return VulnerabilitySeverity.None;
    }

    /**
     * @notice Update validator reputation scores
     * @param _submissionId The submission ID
     * @param _finalDecision Final validation decision
     */
    function _updateValidatorReputations(uint256 _submissionId, bool _finalDecision)
        internal
    {
        address[] memory voters = validationVoters[_submissionId];

        for (uint256 i = 0; i < voters.length; i++) {
            address validator = voters[i];
            ValidationVote memory vote = votes[_submissionId][validator];

            validatorTotalValidations[validator]++;

            // Increase reputation if vote matched final decision
            if (vote.isValid == _finalDecision) {
                validatorReputationScore[validator] += 10;
            } else {
                // Decrease reputation for mismatch
                if (validatorReputationScore[validator] >= 5) {
                    validatorReputationScore[validator] -= 5;
                }
            }
        }
    }

    /**
     * @notice Manually finalize validation (admin only)
     * @param _submissionId The submission ID
     */
    function manualFinalize(uint256 _submissionId)
        external
        onlyRole(ADMIN_ROLE)
    {
        ValidationRequest storage request = validationRequests[_submissionId];
        require(request.totalVotes > 0, "No votes");
        require(!request.isFinalized, "Already finalized");

        _finalizeValidation(_submissionId);
    }

    // Getters
    function getValidationVotes(uint256 _submissionId)
        external
        view
        returns (address[] memory)
    {
        return validationVoters[_submissionId];
    }

    function getValidatorVote(uint256 _submissionId, address _validator)
        external
        view
        returns (ValidationVote memory)
    {
        return votes[_submissionId][_validator];
    }

    function getValidationStatus(uint256 _submissionId)
        external
        view
        returns (
            VulnerabilitySeverity severity,
            ValidationStatus status,
            uint256 totalVotes,
            uint256 approvals,
            uint256 rejections,
            bool isFinalized
        )
    {
        ValidationRequest memory request = validationRequests[_submissionId];
        return (
            request.finalSeverity,
            request.status,
            request.totalVotes,
            request.approvalCount,
            request.rejectionCount,
            request.isFinalized
        );
    }

    // Admin functions
    function addValidator(address _validator) external onlyRole(ADMIN_ROLE) {
        grantRole(VALIDATOR_ROLE, _validator);
        emit ValidatorAdded(_validator);
    }

    function removeValidator(address _validator) external onlyRole(ADMIN_ROLE) {
        revokeRole(VALIDATOR_ROLE, _validator);
        emit ValidatorRemoved(_validator);
    }

    function setBountyManager(address _bountyManager)
        external
        onlyRole(ADMIN_ROLE)
    {
        bountyManager = _bountyManager;
    }

    function setRequiredValidations(uint256 _required)
        external
        onlyRole(ADMIN_ROLE)
    {
        require(_required >= 1 && _required <= 10, "Invalid range");
        requiredValidations = _required;
    }

    function getValidatorStats(address _validator)
        external
        view
        returns (uint256 reputation, uint256 totalValidations)
    {
        return (
            validatorReputationScore[_validator],
            validatorTotalValidations[_validator]
        );
    }
}

interface IBountyManager {
    function validateSubmission(
        uint256 _submissionId,
        uint8 _severity,
        bool _isValid
    ) external;
}
